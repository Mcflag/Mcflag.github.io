<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>92D游戏编程技巧 | 柒夜</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="摘要2D游戏编程技巧">
<meta name="keywords" content="游戏框架">
<meta property="og:type" content="article">
<meta property="og:title" content="92D游戏编程技巧">
<meta property="og:url" content="http://yoursite.com/2015/09/13/Game Frame/92D游戏编程技巧/index.html">
<meta property="og:site_name" content="柒夜">
<meta property="og:description" content="摘要2D游戏编程技巧">
<meta property="og:updated_time" content="2017-06-30T15:16:02.229Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="92D游戏编程技巧">
<meta name="twitter:description" content="摘要2D游戏编程技巧">
  
    <link rel="alternate" href="/atom.xml" title="柒夜" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">柒夜</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">暗夜之虫 会集光中</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Game Frame/92D游戏编程技巧" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/13/Game Frame/92D游戏编程技巧/" class="article-date">
  <time datetime="2015-09-13T15:50:57.000Z" itemprop="datePublished">2015-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      92D游戏编程技巧
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>2D游戏编程技巧<br><a id="more"></a></p>
<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>向量有多种解释：位置，速度和加速度，方向和距离。向量相加(a.x+b.x,a.y+b.y)，向量相减(a.x-b.x，a.y-b.y)，但是减法总是用终点位置减去起点位置。向量相乘（a.x<em>scale，a.y</em>scale）。向量的长度计算sqrt(a.x<em>a.x+a.y</em>a.y)。</p>
<p>下面实现一个向量类，实现构造以及加，减，乘，计算距离等等运算。</p>
<pre><code>public class Vector2 {
    public static float TO_RADIANS = (1 / 180.0f) * (float) Math.PI;
    public static float TO_DEGREES = (1 / (float) Math.PI) * 180;
    public float x, y;

    public Vector2() {
    }

    public Vector2(float x, float y) {
        this.x = x;
        this.y = y;
    }

    public Vector2(Vector2 other) {
        this.x = other.x;
        this.y = other.y;
    }

    public Vector2 cpy() {
        return new Vector2(x, y);
    }

    public Vector2 set(float x, float y) {
        this.x = x;
        this.y = y;
        return this;
    }

    public Vector2 set(Vector2 other) {
        this.x = other.x;
        this.y = other.y;
        return this;
    }

    public Vector2 add(float x, float y) {
        this.x += x;
        this.y += y;
        return this;
    }

    public Vector2 add(Vector2 other) {
        this.x += other.x;
        this.y += other.y;
        return this;
    }

    public Vector2 sub(float x, float y) {
        this.x -= x;
        this.y -= y;
        return this;
    }

    public Vector2 sub(Vector2 other) {
        this.x -= other.x;
        this.y -= other.y;
        return this;
    }

    public Vector2 mul(float scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
    }

    public float len() {
        return FloatMath.sqrt(x * x + y * y);
    }

    public Vector2 nor() {
        float len = len();
        if (len != 0) {
            this.x /= len;
            this.y /= len;
        }
        return this;
    }

    public float angle() {
        float angle = (float) Math.atan2(y, x) * TO_DEGREES;
        if (angle &lt; 0)
            angle += 360;
        return angle;
    }

    public Vector2 rotate(float angle) {
           float rad = angle * TO_RADIANS;
        float cos = FloatMath.cos(rad);
        float sin = FloatMath.sin(rad);

        float newX = this.x * cos - this.y * sin;
        float newY = this.x * sin + this.y * cos;

        this.x = newX;
        this.y = newY;

        return this;
    }

    public float dist(Vector2 other) {
        float distX = this.x - other.x;
        float distY = this.y - other.y;
        return FloatMath.sqrt(distX * distX + distY * distY);
    }

    public float dist(float x, float y) {
        float distX = this.x - x;
        float distY = this.y - y;
        return FloatMath.sqrt(distX * distX + distY * distY);
    }

    public float distSquared(Vector2 other) {
        float distX = this.x - other.x;
        float distY = this.y - other.y;        
        return distX*distX + distY*distY;
    }   

    public float distSquared(float x, float y) {
        float distX = this.x - x;
        float distY = this.y - y;        
        return distX*distX + distY*distY;
    }   
}
</code></pre><h2 id="Vector2类的简单示例：CannonTest类"><a href="#Vector2类的简单示例：CannonTest类" class="headerlink" title="Vector2类的简单示例：CannonTest类"></a>Vector2类的简单示例：CannonTest类</h2><pre><code>public class CannonTest extends GLGame {
    public Screen getStartScreen() {
        return new CannonScreen(this);
    }

    class CannonScreen extends Screen {
        float FRUSTUM_WIDTH = 4.8f;
        float FRUSTUM_HEIGHT = 3.2f;
        GLGraphics glGraphics;
        Vertices vertices;
        Vector2 cannonPos = new Vector2(2.4f, 0.5f);
        float cannonAngle = 0;
        Vector2 touchPos = new Vector2();

        public CannonScreen(Game game) {
            super(game);
            glGraphics = ((GLGame) game).getGLGraphics();
            vertices = new Vertices(glGraphics, 3, 0, false, false);
            vertices.setVertices(new float[] { -0.5f, -0.5f, 
                                            0.5f, 0.0f, 
                                               -0.5f, 0.5f }, 0, 6);
        }

        @Override
        public void update(float deltaTime) {
            List&lt;TouchEvent&gt; touchEvents = game.getInput().getTouchEvents();
            game.getInput().getKeyEvents();

            int len = touchEvents.size();
            for (int i = 0; i &lt; len; i++) {
                TouchEvent event = touchEvents.get(i);
                touchPos.x = (event.x / (float) glGraphics.getWidth()) * FRUSTUM_WIDTH;
                touchPos.y = (1 - event.y / (float) glGraphics.getHeight()) * FRUSTUM_HEIGHT;
                cannonAngle = touchPos.sub(cannonPos).angle();
            }
        }

        @Override
        public void present(float deltaTime) {
            GL10 gl = glGraphics.getGL();
            gl.glViewport(0, 0, glGraphics.getWidth(), glGraphics.getHeight());
            gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
            gl.glMatrixMode(GL10.GL_PROJECTION);
            gl.glLoadIdentity();
            gl.glOrthof(0, FRUSTUM_WIDTH, 0, FRUSTUM_HEIGHT, 1, -1);
            gl.glMatrixMode(GL10.GL_MODELVIEW);
            gl.glLoadIdentity();

            gl.glTranslatef(cannonPos.x, cannonPos.y, 0);
            gl.glRotatef(cannonAngle, 0, 0, 1);
            vertices.bind();
            vertices.draw(GL10.GL_TRIANGLES, 0, 3);
            vertices.unbind();
        }

        @Override
        public void pause() {

        }

        @Override
        public void resume() {

        }

        @Override
        public void dispose() {

        }
    }
}
</code></pre><h2 id="游戏中的物理定律"><a href="#游戏中的物理定律" class="headerlink" title="游戏中的物理定律"></a>游戏中的物理定律</h2><p><strong>质点的运动定律</strong></p>
<p>关注对象的三个属性：位置，速度，加速度。在循环中先使用加速度乘以时间差来更新速度，然后使用速度乘以时间差来更新位置。下面一个例子来说明：</p>
<pre><code>Vector2 position = new Vector2();
Vector2 velocity = new Vector2();
Vector2 acceleration = new Vector2(0,-10);
while(simulationRuns){
    float deltaTime=getDeltaTime();
    if(velocity.len()&lt;55.5){
        velocity.add(acceleration.x*deltaTime,acceleration.y*deltaTime);
    }
    position.add(velocity.x*deltaTime,velocity.y*deltaTime);
}
</code></pre><p><strong>力和质量</strong></p>
<p>总的规律是力=质量*加速度，加速度=力/质量，前面的acceleration为（0，-10），实际上就是地球的重力加速度约值，可以设定为-9.8f。自由落体会有一个最大速度或最终速度。大约为55.5米/秒。</p>
<h2 id="运动的实现"><a href="#运动的实现" class="headerlink" title="运动的实现"></a>运动的实现</h2><p>对CannonTest进行扩展，使其可以发射炮弹。</p>
<ul>
<li>用户的手指在屏幕上拖拽时，三角炮跟踪，确定发射炮弹的角度。</li>
<li>一旦触摸离开，发射炮弹，初始速率等于三角炮和触摸点间的距离。只要没有新的触摸离开事件，炮弹将一直飞。</li>
<li>使视锥体扩大两倍，使其从（0，0）到（9.6，6.4），三角炮的位置在（0，0）</li>
<li>炮弹是0.2米*0.2米的红色矩形。</li>
</ul>
<p>使用一个CannonGravityScreen类：</p>
<pre><code>public class CannonGravityTest extends GLGame {
    public Screen getStartScreen() {
        return new CannonGravityScreen(this);
    }

    class CannonGravityScreen extends Screen {
        float FRUSTUM_WIDTH = 9.6f;
        float FRUSTUM_HEIGHT = 6.4f;
        GLGraphics glGraphics;
        Vertices cannonVertices;
        Vertices ballVertices;
        Vector2 cannonPos = new Vector2();
        float cannonAngle = 0;
        Vector2 touchPos = new Vector2();
        Vector2 ballPos = new Vector2(0, 0);
        Vector2 ballVelocity = new Vector2(0, 0);
        Vector2 gravity = new Vector2(0, -10);

        public CannonGravityScreen(Game game) {
            super(game);
            glGraphics = ((GLGame) game).getGLGraphics();
            cannonVertices = new Vertices(glGraphics, 3, 0, false, false);
            cannonVertices.setVertices(new float[] { -0.5f, -0.5f, 0.5f, 0.0f, -0.5f, 0.5f }, 0, 6);
            ballVertices = new Vertices(glGraphics, 4, 6, false, false);
            ballVertices.setVertices(new float[] { -0.1f, -0.1f, 0.1f, -0.1f, 0.1f, 0.1f, -0.1f, 0.1f }, 0, 8);
            ballVertices.setIndices(new short[] { 0, 1, 2, 2, 3, 0 }, 0, 6);
        }

        @Override
        public void update(float deltaTime) {
            List&lt;TouchEvent&gt; touchEvents = game.getInput().getTouchEvents();
            game.getInput().getKeyEvents();

            int len = touchEvents.size();
            for (int i = 0; i &lt; len; i++) {
                TouchEvent event = touchEvents.get(i);

                touchPos.x = (event.x / (float) glGraphics.getWidth()) * FRUSTUM_WIDTH;
                touchPos.y = (1 - event.y / (float) glGraphics.getHeight()) * FRUSTUM_HEIGHT;
                cannonAngle = touchPos.sub(cannonPos).angle();

                if (event.type == TouchEvent.TOUCH_UP) {
                    float radians = cannonAngle * Vector2.TO_RADIANS;
                    float ballSpeed = touchPos.len();
                    ballPos.set(cannonPos);
                    ballVelocity.x = FloatMath.cos(radians) * ballSpeed;
                    ballVelocity.y = FloatMath.sin(radians) * ballSpeed;
                }
            }

            ballVelocity.add(gravity.x * deltaTime, gravity.y * deltaTime);
            ballPos.add(ballVelocity.x * deltaTime, ballVelocity.y * deltaTime);
        }

        @Override
        public void present(float deltaTime) {

            GL10 gl = glGraphics.getGL();
            gl.glViewport(0, 0, glGraphics.getWidth(), glGraphics.getHeight());
            gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
            gl.glMatrixMode(GL10.GL_PROJECTION);
            gl.glLoadIdentity();
            gl.glOrthof(0, FRUSTUM_WIDTH, 0, FRUSTUM_HEIGHT, 1, -1);
            gl.glMatrixMode(GL10.GL_MODELVIEW);

            gl.glLoadIdentity();
            gl.glTranslatef(cannonPos.x, cannonPos.y, 0);
            gl.glRotatef(cannonAngle, 0, 0, 1);
            gl.glColor4f(1, 1, 1, 1);
            cannonVertices.bind();
            cannonVertices.draw(GL10.GL_TRIANGLES, 0, 3);
            cannonVertices.unbind();

            gl.glLoadIdentity();
            gl.glTranslatef(ballPos.x, ballPos.y, 0);
            gl.glColor4f(1, 0, 0, 1);
            ballVertices.bind();
            ballVertices.draw(GL10.GL_TRIANGLES, 0, 6);
            ballVertices.unbind();
        }

        @Override
        public void pause() {

        }

        @Override
        public void resume() {

        }

        @Override
        public void dispose() {

        }
    }
}
</code></pre><p>首先把三角炮的发射角度转换成弧度，接着计算三角炮和触摸点之间的距离，这是炮弹的速率，最后计算炮弹的真实速度。根据角度，使用正弦和余弦构造方向向量，把这个方向向量乘以炮弹的速率。</p>
<h2 id="游戏对象的属性"><a href="#游戏对象的属性" class="headerlink" title="游戏对象的属性"></a>游戏对象的属性</h2><p>边界形状：三角网格，轴对齐边界盒，边界圆。</p>
<p>虽然在创建模型空间中为映射后的对象建立边界模型，但实际的边界是独立于对象矩形映射到纹理区域。当创建边界形状时，尽可能使这个边界贴近纹理中的对象的轮廓。对象有如下三个属性：</p>
<ul>
<li>它有位置、方向、尺寸、速度和加速度</li>
<li>它的边界形状（通常在模型空间中围绕着对象的中心进行构造）</li>
<li>它的图像显示</li>
</ul>
<p>这些独立的属性允许使用模型试图控制器模式：</p>
<ul>
<li>在模型方面，对象的物理属性由位置，尺寸，旋转，速度，加速度和边界形状构成。</li>
<li>视图只使用对象的图像表示，也就是定义在模型空间中的两个映射过纹理的三角形。并在世界空间上进行渲染。</li>
<li>控制器负责根据用户输入和力的作用更新对象的物理对象。</li>
</ul>
<p>碰撞检测：宽阶段和窄阶段。宽阶段搜寻可能发生碰撞的对象，窄阶段通过对边界形状进行重叠测试来判断他们是否真的发生碰撞。创建三角网格计算边界计算量最大和最繁琐，因此通常使用边界矩形和边界圆。</p>
<p><strong>圆的Circle类</strong></p>
<pre><code>public class Circle {
    public final Vector2 center = new Vector2();
    public float radius;

    public Circle(float x, float y, float radius) {
        this.center.set(x,y);
           this.radius = radius;
    }
}
</code></pre><p><strong>矩形Rectangle类</strong></p>
<pre><code>public class Rectangle {
    public final Vector2 lowerLeft;
    public float width, height;

    public Rectangle(float x, float y, float width, float height) {
        this.lowerLeft = new Vector2(x,y);
        this.width = width;
        this.height = height;
    }    
}
</code></pre><h3 id="窄阶段检测"><a href="#窄阶段检测" class="headerlink" title="窄阶段检测"></a>窄阶段检测</h3><p><strong>碰撞检测类的示例</strong></p>
<pre><code>public class OverlapTester {
    public static boolean overlapCircles(Circle c1, Circle c2) {
        float distance = c1.center.distSquared(c2.center);
        float radiusSum = c1.radius + c2.radius;
        return distance &lt;= radiusSum * radiusSum;
    }

    public static boolean overlapRectangles(Rectangle r1, Rectangle r2) {
        if(r1.lowerLeft.x &lt; r2.lowerLeft.x + r2.width &amp;&amp; r1.lowerLeft.x + r1.width &gt; r2.lowerLeft.x &amp;&amp; r1.lowerLeft.y &lt; r2.lowerLeft.y + r2.height &amp;&amp; r1.lowerLeft.y + r1.height &gt; r2.lowerLeft.y)
            return true;
        else
            return false;
    }

    public static boolean overlapCircleRectangle(Circle c, Rectangle r) {
        float closestX = c.center.x;
        float closestY = c.center.y;

        if(c.center.x &lt; r.lowerLeft.x) {
            closestX = r.lowerLeft.x; 
        } 
        else if(c.center.x &gt; r.lowerLeft.x + r.width) {
            closestX = r.lowerLeft.x + r.width;
        }

        if(c.center.y &lt; r.lowerLeft.y) {
            closestY = r.lowerLeft.y;
        } 
        else if(c.center.y &gt; r.lowerLeft.y + r.height) {
            closestY = r.lowerLeft.y + r.height;
        }

        return c.center.distSquared(closestX, closestY) &lt; c.radius * c.radius;           
    }

    public static boolean pointInCircle(Circle c, Vector2 p) {
        return c.center.distSquared(p) &lt; c.radius * c.radius;
    }

    public static boolean pointInCircle(Circle c, float x, float y) {
        return c.center.distSquared(x, y) &lt; c.radius * c.radius;
    }

    public static boolean pointInRectangle(Rectangle r, Vector2 p) {
        return r.lowerLeft.x &lt;= p.x &amp;&amp; r.lowerLeft.x + r.width &gt;= p.x &amp;&amp; r.lowerLeft.y &lt;= p.y &amp;&amp; r.lowerLeft.y + r.height &gt;= p.y;
    }

    public static boolean pointInRectangle(Rectangle r, float x, float y) {
        return r.lowerLeft.x &lt;= x &amp;&amp; r.lowerLeft.x + r.width &gt;= x &amp;&amp; r.lowerLeft.y &lt;= y &amp;&amp; r.lowerLeft.y + r.height &gt;= y;
    }
}
</code></pre><h3 id="宽阶段检测"><a href="#宽阶段检测" class="headerlink" title="宽阶段检测"></a>宽阶段检测</h3><p>将画面分为单元格，如果一个对象与其他对象不在一个单元格内，需要做的就是如下工作：</p>
<ul>
<li>根据物理和控制器步骤更新画面中的所有对象。</li>
<li>根据每个对象的位置更新该对象的边界形状和位置，当然也包含该对象的方向和尺寸。</li>
<li>根据每个对象的边界形状寻找包含该对象的一个或几个单元格，并将其添加到这些单元格所包含的对象列表里。</li>
<li>只检测可以发生碰撞并且位于相同单元格的对象对之间的碰撞。</li>
</ul>
<p>这就是空间散列网格宽阶段检测，首先需要定义单元格的大小，这高度依赖游戏世界的规模和所使用的单位。</p>
<h2 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h2><p><strong>GameObject类</strong></p>
<p>这是一个静态的对象，游戏中每一个对象都有一个位置，这个位置就是它的中心。</p>
<pre><code>public class GameObject {
    public final Vector2 position;
    public final Rectangle bounds;

    public GameObject(float x, float y, float width, float height) {
        this.position = new Vector2(x,y);
        this.bounds = new Rectangle(x-width/2, y-height/2, width, height);
    }
}
</code></pre><p><strong>DynamicGameObject类</strong></p>
<p>这是一个动态的对象，需要记录它们的速度和加速度。</p>
<pre><code>public class DynamicGameObject extends GameObject {
    public final Vector2 velocity;
    public final Vector2 accel;

    public DynamicGameObject(float x, float y, float width, float height) {
        super(x, y, width, height);
        velocity = new Vector2();
        accel = new Vector2();
    }
}
</code></pre><p><strong>Cannon类</strong></p>
<p>从GameObject派生一个Cannon，并添加一个字段存储炮当前的角度。</p>
<pre><code>public class Cannon extends GameObject {
    public float angle;

    public Cannon(float x, float y, float width, float height) {
        super(x, y, width, height);
        angle = 0;
    }
}
</code></pre><p><strong>空间散列网格实现</strong></p>
<p>我们使用两个单元格列表，一个用来存储动态对象，一个存储静态对象。代码中也保存了每行和每列的单元格，使用它们来判断一个点是否处在画面之中。单元格的大小也需要保存，cellIds保存对象所处的4个单元格ID。</p>
<pre><code>public class SpatialHashGrid {
    List&lt;GameObject&gt;[] dynamicCells;
    List&lt;GameObject&gt;[] staticCells;
    int cellsPerRow;
    int cellsPerCol;
    float cellSize;
    int[] cellIds = new int[4];
    List&lt;GameObject&gt; foundObjects;

    public SpatialHashGrid(float worldWidth, float worldHeight, float cellSize) {
        this.cellSize = cellSize;
        this.cellsPerRow = (int)FloatMath.ceil(worldWidth/cellSize);
        this.cellsPerCol = (int)FloatMath.ceil(worldHeight/cellSize);
        int numCells = cellsPerRow * cellsPerCol;
        dynamicCells = new List[numCells];
        staticCells = new List[numCells];
        for(int i = 0; i &lt; numCells; i++) {
            dynamicCells[i] = new ArrayList&lt;GameObject&gt;(10);
            staticCells[i] = new ArrayList&lt;GameObject&gt;(10);
        }
        foundObjects = new ArrayList&lt;GameObject&gt;(10);
    }

    public void insertStaticObject(GameObject obj) {
        int[] cellIds = getCellIds(obj);
        int i = 0;
        int cellId = -1;
        while(i &lt;= 3 &amp;&amp; (cellId = cellIds[i++]) != -1) {
            staticCells[cellId].add(obj);
        }
    }

    public void insertDynamicObject(GameObject obj) {
        int[] cellIds = getCellIds(obj);
        int i = 0;
        int cellId = -1;
        while(i &lt;= 3 &amp;&amp; (cellId = cellIds[i++]) != -1) {
            dynamicCells[cellId].add(obj);
        }
    }

    public void removeObject(GameObject obj) {
        int[] cellIds = getCellIds(obj);
        int i = 0;
        int cellId = -1;
        while(i &lt;= 3 &amp;&amp; (cellId = cellIds[i++]) != -1) {
            dynamicCells[cellId].remove(obj);
            staticCells[cellId].remove(obj);
        }
    }

    public void clearDynamicCells(GameObject obj) {
        int len = dynamicCells.length;
        for(int i = 0; i &lt; len; i++) {
            dynamicCells[i].clear();
        }
    }   

    public List&lt;GameObject&gt; getPotentialColliders(GameObject obj) {
        foundObjects.clear();
        int[] cellIds = getCellIds(obj);
        int i = 0;
        int cellId = -1;
        while(i &lt;= 3 &amp;&amp; (cellId = cellIds[i++]) != -1) {
            int len = dynamicCells[cellId].size();
            for(int j = 0; j &lt; len; j++) {
                GameObject collider = dynamicCells[cellId].get(j);
                if(!foundObjects.contains(collider))
                    foundObjects.add(collider);
            }

            len = staticCells[cellId].size();
            for(int j = 0; j &lt; len; j++) {
                GameObject collider = staticCells[cellId].get(j);
                if(!foundObjects.contains(collider))
                    foundObjects.add(collider);
            }
        }
        return foundObjects;
    }

    public int[] getCellIds(GameObject obj) {
        int x1 = (int)FloatMath.floor(obj.bounds.lowerLeft.x / cellSize);
        int y1 = (int)FloatMath.floor(obj.bounds.lowerLeft.y / cellSize);
        int x2 = (int)FloatMath.floor((obj.bounds.lowerLeft.x + obj.bounds.width) / cellSize);
        int y2 = (int)FloatMath.floor((obj.bounds.lowerLeft.y + obj.bounds.height) / cellSize);

        if(x1 == x2 &amp;&amp; y1 == y2) {
            if(x1 &gt;= 0 &amp;&amp; x1 &lt; cellsPerRow &amp;&amp; y1 &gt;= 0 &amp;&amp; y1 &lt; cellsPerCol)
                cellIds[0] = x1 + y1 * cellsPerRow;
            else
                cellIds[0] = -1;
            cellIds[1] = -1;
            cellIds[2] = -1;
            cellIds[3] = -1;
        }
        else if(x1 == x2) {
            int i = 0;
            if(x1 &gt;= 0 &amp;&amp; x1 &lt; cellsPerRow) {
                if(y1 &gt;= 0 &amp;&amp; y1 &lt; cellsPerCol)
                    cellIds[i++] = x1 + y1 * cellsPerRow;
                if(y2 &gt;= 0 &amp;&amp; y2 &lt; cellsPerCol)
                    cellIds[i++] = x1 + y2 * cellsPerRow;
            }
            while(i &lt;= 3) cellIds[i++] = -1;
        }
        else if(y1 == y2) {
            int i = 0;
            if(y1 &gt;= 0 &amp;&amp; y1 &lt; cellsPerCol) {
                if(x1 &gt;= 0 &amp;&amp; x1 &lt; cellsPerRow)
                    cellIds[i++] = x1 + y1 * cellsPerRow;
                if(x2 &gt;= 0 &amp;&amp; x2 &lt; cellsPerRow)
                    cellIds[i++] = x2 + y1 * cellsPerRow;
            }
            while(i &lt;= 3) cellIds[i++] = -1;                       
        }
        else {
            int i = 0;
            int y1CellsPerRow = y1 * cellsPerRow;
            int y2CellsPerRow = y2 * cellsPerRow;
            if(x1 &gt;= 0 &amp;&amp; x1 &lt; cellsPerRow &amp;&amp; y1 &gt;= 0 &amp;&amp; y1 &lt; cellsPerCol)
                cellIds[i++] = x1 + y1CellsPerRow;
            if(x2 &gt;= 0 &amp;&amp; x2 &lt; cellsPerRow &amp;&amp; y1 &gt;= 0 &amp;&amp; y1 &lt; cellsPerCol)
                cellIds[i++] = x2 + y1CellsPerRow;
            if(x2 &gt;= 0 &amp;&amp; x2 &lt; cellsPerRow &amp;&amp; y2 &gt;= 0 &amp;&amp; y2 &lt; cellsPerCol)
                cellIds[i++] = x2 + y2CellsPerRow;
            if(x1 &gt;= 0 &amp;&amp; x1 &lt; cellsPerRow &amp;&amp; y2 &gt;= 0 &amp;&amp; y2 &lt; cellsPerCol)
                cellIds[i++] = x1 + y2CellsPerRow;CannonGravityTest
            while(i &lt;= 3) cellIds[i++] = -1;
        }
        return cellIds;
    }
}
</code></pre><h2 id="示例进行碰撞检测CollisionTest类"><a href="#示例进行碰撞检测CollisionTest类" class="headerlink" title="示例进行碰撞检测CollisionTest类"></a>示例进行碰撞检测CollisionTest类</h2><pre><code>public class CollisionTest extends GLGame {

    public Screen getStartScreen() {
        return new CollisionScreen(this);
    }

    class CollisionScreen extends Screen {
        final int NUM_TARGETS = 20;
        final float WORLD_WIDTH = 9.6f;
        final float WORLD_HEIGHT = 4.8f;
        GLGraphics glGraphics;
        Cannon cannon;
        DynamicGameObject ball;
        List&lt;GameObject&gt; targets;
        SpatialHashGrid grid;

        Vertices cannonVertices;
        Vertices ballVertices;
        Vertices targetVertices;

        Vector2 touchPos = new Vector2();
        Vector2 gravity = new Vector2(0, -10);

        public CollisionScreen(Game game) {
            super(game);
            glGraphics = ((GLGame) game).getGLGraphics();

            cannon = new Cannon(0, 0, 1, 1);
            ball = new DynamicGameObject(0, 0, 0.2f, 0.2f);
            targets = new ArrayList&lt;GameObject&gt;(NUM_TARGETS);
            grid = new SpatialHashGrid(WORLD_WIDTH, WORLD_HEIGHT, 2.5f);
            for (int i = 0; i &lt; NUM_TARGETS; i++) {
                GameObject target = new GameObject((float) Math.random() * WORLD_WIDTH, (float) Math.random() * WORLD_HEIGHT, 0.5f, 0.5f);
                grid.insertStaticObject(target);
                targets.add(target);
            }

            cannonVertices = new Vertices(glGraphics, 3, 0, false, false);
            cannonVertices.setVertices(new float[] { -0.5f, -0.5f, 0.5f, 0.0f, -0.5f, 0.5f }, 0, 6);

            ballVertices = new Vertices(glGraphics, 4, 6, false, false);
            ballVertices.setVertices(new float[] { -0.1f, -0.1f, 0.1f, -0.1f, 0.1f, 0.1f, -0.1f, 0.1f }, 0, 8);
            ballVertices.setIndices(new short[] { 0, 1, 2, 2, 3, 0 }, 0, 6);

            targetVertices = new Vertices(glGraphics, 4, 6, false, false);
            targetVertices.setVertices(new float[] { -0.25f, -0.25f, 0.25f, -0.25f, 0.25f, 0.25f, -0.25f, 0.25f }, 0, 8);
            targetVertices.setIndices(new short[] { 0, 1, 2, 2, 3, 0 }, 0, 6);
        }

        public void update(float deltaTime) {
            List&lt;TouchEvent&gt; touchEvents = game.getInput().getTouchEvents();
            game.getInput().getKeyEvents();

            int len = touchEvents.size();
            for (int i = 0; i &lt; len; i++) {
                TouchEvent event = touchEvents.get(i);

                touchPos.x = (event.x / (float) glGraphics.getWidth()) * WORLD_WIDTH;
                touchPos.y = (1 - event.y / (float) glGraphics.getHeight()) * WORLD_HEIGHT;

                cannon.angle = touchPos.sub(cannon.position).angle();

                if (event.type == TouchEvent.TOUCH_UP) {
                    float radians = cannon.angle * Vector2.TO_RADIANS;
                    float ballSpeed = touchPos.len() * 2;
                    ball.position.set(cannon.position);
                    ball.velocity.x = FloatMath.cos(radians) * ballSpeed;
                    ball.velocity.y = FloatMath.sin(radians) * ballSpeed;
                    ball.bounds.lowerLeft.set(ball.position.x - 0.1f, ball.position.y - 0.1f);
                }
            }

            ball.velocity.add(gravity.x * deltaTime, gravity.y * deltaTime);
            ball.position.add(ball.velocity.x * deltaTime, ball.velocity.y * deltaTime);
            ball.bounds.lowerLeft.add(ball.velocity.x * deltaTime, ball.velocity.y * deltaTime);

            List&lt;GameObject&gt; colliders = grid.getPotentialColliders(ball);
            len = colliders.size();
            for (int i = 0; i &lt; len; i++) {
                GameObject collider = colliders.get(i);
                if (OverlapTester.overlapRectangles(ball.bounds, collider.bounds)) {
                    grid.removeObject(collider);
                    targets.remove(collider);
                }
            }
        }

        public void present(float deltaTime) {
            GL10 gl = glGraphics.getGL();
            gl.glViewport(0, 0, glGraphics.getWidth(), glGraphics.getHeight());
            gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
            gl.glMatrixMode(GL10.GL_PROJECTION);
            gl.glLoadIdentity();
            gl.glOrthof(0, WORLD_WIDTH, 0, WORLD_HEIGHT, 1, -1);
            gl.glMatrixMode(GL10.GL_MODELVIEW);

            gl.glColor4f(0, 1, 0, 1);
            targetVertices.bind();
            int len = targets.size();
            for (int i = 0; i &lt; len; i++) {
                GameObject target = targets.get(i);
                gl.glLoadIdentity();
                gl.glTranslatef(target.position.x, target.position.y, 0);
                targetVertices.draw(GL10.GL_TRIANGLES, 0, 6);
            }
            targetVertices.unbind();

            gl.glLoadIdentity();
            gl.glTranslatef(ball.position.x, ball.position.y, 0);
            gl.glColor4f(1, 0, 0, 1);
            ballVertices.bind();
            ballVertices.draw(GL10.GL_TRIANGLES, 0, 6);
            ballVertices.unbind();

            gl.glLoadIdentity();
            gl.glTranslatef(cannon.position.x, cannon.position.y, 0);
            gl.glRotatef(cannon.angle, 0, 0, 1);
            gl.glColor4f(1, 1, 1, 1);
            cannonVertices.bind();
            cannonVertices.draw(GL10.GL_TRIANGLES, 0, 3);
            cannonVertices.unbind();
        }

        @Override
        public void pause() {
        }

        @Override
        public void resume() {
        }

        @Override
        public void dispose() {
        }
    }
}
</code></pre><h2 id="2D照相机"><a href="#2D照相机" class="headerlink" title="2D照相机"></a>2D照相机</h2><p>实际上可以在空间中任意移动视锥，可以很容易指定左下角的位置。也可以将视锥的中心定位，可以容易的定位到特定的位置的对象上。下面是Camera2D类的代码：</p>
<pre><code>public class Camera2D {
    public final Vector2 position;
    public float zoom;
    public final float frustumWidth;
    public final float frustumHeight;
    final GLGraphics glGraphics;

    public Camera2D(GLGraphics glGraphics, float frustumWidth, float frustumHeight) {
        this.glGraphics = glGraphics;
        this.frustumWidth = frustumWidth;
        this.frustumHeight = frustumHeight;
        this.position = new Vector2(frustumWidth / 2, frustumHeight / 2);
        this.zoom = 1.0f;
    }

    public void setViewportAndMatrices() {
        GL10 gl = glGraphics.getGL();
        gl.glViewport(0, 0, glGraphics.getWidth(), glGraphics.getHeight());
        gl.glMatrixMode(GL10.GL_PROJECTION);
        gl.glLoadIdentity();
        gl.glOrthof(position.x - frustumWidth * zoom / 2, 
                position.x + frustumWidth * zoom/ 2, 
                position.y - frustumHeight * zoom / 2, 
                position.y + frustumHeight * zoom/ 2, 
                1, -1);
        gl.glMatrixMode(GL10.GL_MODELVIEW);
        gl.glLoadIdentity();
    }

    public void touchToWorld(Vector2 touch) {
        touch.x = (touch.x / (float) glGraphics.getWidth()) * frustumWidth * zoom;
        touch.y = (1 - touch.y / (float) glGraphics.getHeight()) * frustumHeight * zoom;
        touch.add(position).sub(frustumWidth * zoom / 2, frustumHeight * zoom / 2);
    }
}
</code></pre><p><strong>测试的实例Camera2DTest类</strong></p>
<p>这个示例的作用是让照相机跟踪炮弹。</p>
<pre><code>public class Camera2DTest extends GLGame {

    public Screen getStartScreen() {
        return new Camera2DScreen(this);
    }

    class Camera2DScreen extends Screen {
        final int NUM_TARGETS = 20;
        final float WORLD_WIDTH = 9.6f;
        final float WORLD_HEIGHT = 4.8f;
        GLGraphics glGraphics;
        Cannon cannon;
        DynamicGameObject ball;
        List&lt;GameObject&gt; targets;
        SpatialHashGrid grid;

        Vertices cannonVertices;
        Vertices ballVertices;
        Vertices targetVertices;

        Vector2 touchPos = new Vector2();
        Vector2 gravity = new Vector2(0, -10);

        Camera2D camera;

        public Camera2DScreen(Game game) {
            super(game);
            glGraphics = ((GLGame) game).getGLGraphics();

            cannon = new Cannon(0, 0, 1, 1);
            ball = new DynamicGameObject(0, 0, 0.2f, 0.2f);
            targets = new ArrayList&lt;GameObject&gt;(NUM_TARGETS);
            grid = new SpatialHashGrid(WORLD_WIDTH, WORLD_HEIGHT, 2.5f);
            for (int i = 0; i &lt; NUM_TARGETS; i++) {
                GameObject target = new GameObject((float) Math.random() * WORLD_WIDTH, (float) Math.random() * WORLD_HEIGHT, 0.5f, 0.5f);
                grid.insertStaticObject(target);
                targets.add(target);
            }

            cannonVertices = new Vertices(glGraphics, 3, 0, false, false);
            cannonVertices.setVertices(new float[] { -0.5f, -0.5f, 0.5f, 0.0f, -0.5f, 0.5f }, 0, 6);

            ballVertices = new Vertices(glGraphics, 4, 6, false, false);
            ballVertices.setVertices(new float[] { -0.1f, -0.1f, 0.1f, -0.1f, 0.1f, 0.1f, -0.1f, 0.1f }, 0, 8);
            ballVertices.setIndices(new short[] { 0, 1, 2, 2, 3, 0 }, 0, 6);

            targetVertices = new Vertices(glGraphics, 4, 6, false, false);
            targetVertices.setVertices(new float[] { -0.25f, -0.25f, 0.25f, -0.25f, 0.25f, 0.25f, -0.25f, 0.25f }, 0, 8);
            targetVertices.setIndices(new short[] { 0, 1, 2, 2, 3, 0 }, 0, 6);

            camera = new Camera2D(glGraphics, WORLD_WIDTH, WORLD_HEIGHT);
        }

        public void update(float deltaTime) {
            List&lt;TouchEvent&gt; touchEvents = game.getInput().getTouchEvents();
            game.getInput().getKeyEvents();

            int len = touchEvents.size();
            for (int i = 0; i &lt; len; i++) {
                TouchEvent event = touchEvents.get(i);

                camera.touchToWorld(touchPos.set(event.x, event.y));

                cannon.angle = touchPos.sub(cannon.position).angle();

                if (event.type == TouchEvent.TOUCH_UP) {
                    float radians = cannon.angle * Vector2.TO_RADIANS;
                    float ballSpeed = touchPos.len() * 2;
                    ball.position.set(cannon.position);
                    ball.velocity.x = FloatMath.cos(radians) * ballSpeed;
                    ball.velocity.y = FloatMath.sin(radians) * ballSpeed;
                    ball.bounds.lowerLeft.set(ball.position.x - 0.1f, ball.position.y - 0.1f);
                }
            }

            ball.velocity.add(gravity.x * deltaTime, gravity.y * deltaTime);
            ball.position.add(ball.velocity.x * deltaTime, ball.velocity.y * deltaTime);
            ball.bounds.lowerLeft.add(ball.velocity.x * deltaTime, ball.velocity.y * deltaTime);

            List&lt;GameObject&gt; colliders = grid.getPotentialColliders(ball);
            len = colliders.size();
            for (int i = 0; i &lt; len; i++) {
                GameObject collider = colliders.get(i);
                if (OverlapTester.overlapRectangles(ball.bounds, collider.bounds)) {
                    grid.removeObject(collider);
                    targets.remove(collider);
                }
            }

            if (ball.position.y &gt; 0) {
                camera.position.set(ball.position);
                camera.zoom = 1 + ball.position.y / WORLD_HEIGHT;
            } else {
                camera.position.set(WORLD_WIDTH / 2, WORLD_HEIGHT / 2);
                camera.zoom = 1;
            }
        }

        public void present(float deltaTime) {
            GL10 gl = glGraphics.getGL();
            gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
            camera.setViewportAndMatrices();

            gl.glColor4f(0, 1, 0, 1);
            targetVertices.bind();
            int len = targets.size();
            for (int i = 0; i &lt; len; i++) {
                GameObject target = targets.get(i);
                gl.glLoadIdentity();
                gl.glTranslatef(target.position.x, target.position.y, 0);
                targetVertices.draw(GL10.GL_TRIANGLES, 0, 6);
            }
            targetVertices.unbind();

            gl.glLoadIdentity();
            gl.glTranslatef(ball.position.x, ball.position.y, 0);
            gl.glColor4f(1, 0, 0, 1);
            ballVertices.bind();
            ballVertices.draw(GL10.GL_TRIANGLES, 0, 6);
            ballVertices.unbind();

            gl.glLoadIdentity();
            gl.glTranslatef(cannon.position.x, cannon.position.y, 0);
            gl.glRotatef(cannon.angle, 0, 0, 1);
            gl.glColor4f(1, 1, 1, 1);
            cannonVertices.bind();
            cannonVertices.draw(GL10.GL_TRIANGLES, 0, 3);
            cannonVertices.unbind();
        }

        @Override
        public void pause() {
        }

        @Override
        public void resume() {
        }

        @Override
        public void dispose() {
        }
    }
}
</code></pre><h2 id="纹理图集"><a href="#纹理图集" class="headerlink" title="纹理图集"></a>纹理图集</h2><p>如果有多个纹理的情况下，需要为每种对象类型切换纹理，这样效率并不高。可以将多个纹理放在一张图片中，组成纹理图集，这样可以节省状态转换工作量，提高性能。例子选择64像素对应空间中的1米，纹理的宽度和高度必须是2的倍数，这样处理比较方便。不过也可以使用更多的像素，取决于屏幕大小。下面是使用纹理图集的示例TextureAtlasTest类。</p>
<pre><code>public class TextureAtlasTest extends GLGame {

    public Screen getStartScreen() {
        return new TextureAtlasScreen(this);
    }

    class TextureAtlasScreen extends Screen {
        final int NUM_TARGETS = 20;
        final float WORLD_WIDTH = 9.6f;
        final float WORLD_HEIGHT = 4.8f;
        GLGraphics glGraphics;        
        Cannon cannon;
        DynamicGameObject ball;
        List&lt;GameObject&gt; targets;
        SpatialHashGrid grid;

        Vertices cannonVertices;
        Vertices ballVertices;
        Vertices targetVertices;

        Vector2 touchPos = new Vector2();
        Vector2 gravity = new Vector2(0,-10);

        Camera2D camera;

        Texture texture;

        public TextureAtlasScreen(Game game) {
            super(game);
            glGraphics = ((GLGame)game).getGLGraphics();

            cannon = new Cannon(0, 0, 1, 0.5f);
            ball = new DynamicGameObject(0, 0, 0.2f, 0.2f);
            targets = new ArrayList&lt;GameObject&gt;(NUM_TARGETS);
            grid = new SpatialHashGrid(WORLD_WIDTH, WORLD_HEIGHT, 2.5f);
            for(int i = 0; i &lt; NUM_TARGETS; i++) {
                GameObject target = new GameObject((float)Math.random() * WORLD_WIDTH, 
                                               (float)Math.random() * WORLD_HEIGHT,
                                               0.5f, 0.5f);  
                grid.insertStaticObject(target);
                targets.add(target);
            }                        

            cannonVertices = new Vertices(glGraphics, 4, 6, false, true);
            cannonVertices.setVertices(new float[] { -0.5f, -0.25f, 0.0f, 0.5f, 
                                                  0.5f, -0.25f, 1.0f, 0.5f,
                                                  0.5f,  0.25f, 1.0f, 0.0f,
                                                 -0.5f,  0.25f, 0.0f, 0.0f }, 
                                                 0, 16);
            cannonVertices.setIndices(new short[] {0, 1, 2, 2, 3, 0}, 0, 6);

            ballVertices = new Vertices(glGraphics, 4, 6, false, true);            
            ballVertices.setVertices(new float[] { -0.1f, -0.1f, 0.0f, 0.75f,
                                                0.1f, -0.1f, 0.25f, 0.75f,
                                                0.1f,  0.1f, 0.25f, 0.5f,
                                               -0.1f,  0.1f, 0.0f, 0.5f }, 
                                                0, 16);
            ballVertices.setIndices(new short[] {0, 1, 2, 2, 3, 0}, 0, 6);

            targetVertices = new Vertices(glGraphics, 4, 6, false, true);
            targetVertices.setVertices(new float[] { -0.25f, -0.25f, 0.5f, 1.0f,
                                                  0.25f, -0.25f, 1.0f, 1.0f,
                                                  0.25f,  0.25f, 1.0f, 0.5f,
                                                 -0.25f,  0.25f, 0.5f, 0.5f }, 
                                                 0, 16);
            targetVertices.setIndices(new short[] {0, 1, 2, 2, 3, 0}, 0, 6);

            camera = new Camera2D(glGraphics, WORLD_WIDTH, WORLD_HEIGHT);
        }

        @Override
        public void update(float deltaTime) {
            List&lt;TouchEvent&gt; touchEvents = game.getInput().getTouchEvents();
            game.getInput().getKeyEvents();

            int len = touchEvents.size();
            for (int i = 0; i &lt; len; i++) {
                TouchEvent event = touchEvents.get(i);

                camera.touchToWorld(touchPos.set(event.x, event.y));

                cannon.angle = touchPos.sub(cannon.position).angle();                       

                if(event.type == TouchEvent.TOUCH_UP) {
                    float radians = cannon.angle * Vector2.TO_RADIANS;
                    float ballSpeed = touchPos.len() * 2;
                    ball.position.set(cannon.position);
                    ball.velocity.x = FloatMath.cos(radians) * ballSpeed;
                    ball.velocity.y = FloatMath.sin(radians) * ballSpeed;
                    ball.bounds.lowerLeft.set(ball.position.x - 0.1f, ball.position.y - 0.1f);
                }
            }

            ball.velocity.add(gravity.x * deltaTime, gravity.y * deltaTime);
            ball.position.add(ball.velocity.x * deltaTime, ball.velocity.y * deltaTime);
            ball.bounds.lowerLeft.add(ball.velocity.x * deltaTime, ball.velocity.y * deltaTime);

            List&lt;GameObject&gt; colliders = grid.getPotentialColliders(ball);
            len = colliders.size(); 
            for(int i = 0; i &lt; len; i++) {
                GameObject collider = colliders.get(i);
                if(OverlapTester.overlapRectangles(ball.bounds, collider.bounds)) {
                    grid.removeObject(collider);
                    targets.remove(collider);
                }
            }

            if(ball.position.y &gt; 0) {
                camera.position.set(ball.position);
                camera.zoom = 1 + ball.position.y / WORLD_HEIGHT; 
            } else {
                camera.position.set(WORLD_WIDTH / 2, WORLD_HEIGHT / 2);
                camera.zoom = 1;
            }
        }

        @Override
        public void present(float deltaTime) {
            GL10 gl = glGraphics.getGL();
            gl.glClear(GL10.GL_COLOR_BUFFER_BIT);
            camera.setViewportAndMatrices();

            gl.glEnable(GL10.GL_BLEND);
            gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);
            gl.glEnable(GL10.GL_TEXTURE_2D);
            texture.bind();

            targetVertices.bind();
            int len = targets.size();
            for(int i = 0; i &lt; len; i++) {               
                GameObject target = targets.get(i);
                gl.glLoadIdentity();
                gl.glTranslatef(target.position.x, target.position.y, 0);
                targetVertices.draw(GL10.GL_TRIANGLES, 0, 6);
            }
            targetVertices.unbind();

            gl.glLoadIdentity();
            gl.glTranslatef(ball.position.x, ball.position.y, 0);            
            ballVertices.bind();
            ballVertices.draw(GL10.GL_TRIANGLES, 0, 6);
            ballVertices.unbind();  

            gl.glLoadIdentity();
            gl.glTranslatef(cannon.position.x, cannon.position.y, 0);
            gl.glRotatef(cannon.angle, 0, 0, 1);            
            cannonVertices.bind();
            cannonVertices.draw(GL10.GL_TRIANGLES, 0, 6);
            cannonVertices.unbind();                    
        }

        @Override
        public void pause() {
        }

        @Override
        public void resume() {
            texture = new Texture(((GLGame)game), &quot;atlas.png&quot;);
        }

        @Override
        public void dispose() {
        }
    }
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/09/13/Game Frame/92D游戏编程技巧/" data-id="cj4k85i8j002eis6k1pxx66jm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/游戏框架/">游戏框架</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/09/17/Game Frame/102D游戏编程技巧下/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          102D游戏编程技巧下
        
      </div>
    </a>
  
  
    <a href="/2015/09/12/Game Frame/8OpenGL示例下/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">8OpenGL示例下</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android基础/">Android基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android官方培训教程/">Android官方培训教程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitHub-Page/">GitHub Page</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/">PHP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/libgdx/">libgdx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码大全/">代码大全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术/">技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂谈/">杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/游戏框架/">游戏框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法导论/">算法导论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/静态独立博客/">静态独立博客</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android基础/" style="font-size: 16px;">Android基础</a> <a href="/tags/Android官方培训教程/" style="font-size: 18px;">Android官方培训教程</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/GitHub-Page/" style="font-size: 10px;">GitHub Page</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/PHP/" style="font-size: 10px;">PHP</a> <a href="/tags/libgdx/" style="font-size: 14px;">libgdx</a> <a href="/tags/代码大全/" style="font-size: 16px;">代码大全</a> <a href="/tags/技术/" style="font-size: 10px;">技术</a> <a href="/tags/杂谈/" style="font-size: 10px;">杂谈</a> <a href="/tags/游戏框架/" style="font-size: 20px;">游戏框架</a> <a href="/tags/算法导论/" style="font-size: 12px;">算法导论</a> <a href="/tags/静态独立博客/" style="font-size: 10px;">静态独立博客</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/12/28/Other/GitHub-Pages-Hexo搭建博客/">GitHub Pages + Hexo搭建博客</a>
          </li>
        
          <li>
            <a href="/2016/04/11/Android programming the big nerd ranch guide/Android编程权威指南笔记1/">Android编程权威指南笔记1</a>
          </li>
        
          <li>
            <a href="/2016/04/08/php/PHP基础函数1/">PHP基础函数1</a>
          </li>
        
          <li>
            <a href="/2015/10/15/libgdx/libgdx教程4——控件（未完成）/">Libgdx教程4——控件</a>
          </li>
        
          <li>
            <a href="/2015/10/13/libgdx/libgdx教程3——动画/">Libgdx教程3——动画</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 柒夜<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>